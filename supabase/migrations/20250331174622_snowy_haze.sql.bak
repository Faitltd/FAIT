/*
  # Admin System Setup

  1. New Tables
    - `admin_users`: Stores admin user information
    - `admin_roles`: Defines admin role types and permissions
    - `admin_audit_logs`: Tracks admin actions for accountability

  2. Security
    - Enable RLS on all tables
    - Add policies for admin access
    - Create admin-specific functions

  3. Changes
    - Add admin verification fields to contractor_verifications
    - Add admin handling fields to warranty_claims
*/

-- Create admin_roles enum
CREATE TYPE admin_role_type AS ENUM (
  'super_admin',
  'verification_admin',
  'warranty_admin',
  'support_admin'
);

-- Create admin_users table
CREATE TABLE admin_users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  role admin_role_type NOT NULL,
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create admin_audit_logs table
CREATE TABLE admin_audit_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id uuid REFERENCES admin_users(id) ON DELETE SET NULL,
  action text NOT NULL,
  entity_type text NOT NULL,
  entity_id uuid NOT NULL,
  changes jsonb,
  created_at timestamptz DEFAULT now()
);

-- Add admin handling fields to warranty_claims
-- Ensure warranty_claims table exists before altering
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'warranty_claims') THEN
    RAISE EXCEPTION 'Table warranty_claims does not exist';
  END IF;
END $$;

ALTER TABLE warranty_claims
ADD COLUMN IF NOT EXISTS assigned_admin_id uuid REFERENCES admin_users(id),
ADD COLUMN IF NOT EXISTS admin_notes text,
-- Ensure admin_users table exists before creating function
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'admin_users') THEN
    RAISE EXCEPTION 'Table admin_users does not exist';
  END IF;
END $$;

CREATE OR REPLACE FUNCTION is_admin(user_id uuid)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM admin_users
    WHERE user_id = $1 AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM admin_users
    WHERE user_id = $1 AND is_active = true
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create admin audit function
CREATE OR REPLACE FUNCTION log_admin_action()
RETURNS trigger AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    INSERT INTO admin_audit_logs (
      admin_id,
      action,
      entity_type,
      entity_id,
      changes
    )
    VALUES (
      (SELECT id FROM admin_users WHERE user_id = auth.uid()),
      TG_OP,
      TG_TABLE_NAME,
      NEW.id,
      jsonb_build_object(
        'old', to_jsonb(OLD),
        'new', to_jsonb(NEW)
      )
    );
  ELSIF (TG_OP = 'INSERT' OR TG_OP = 'DELETE') THEN
    INSERT INTO admin_audit_logs (
      admin_id,
      action,
      entity_type,
      entity_id,
      changes
    )
-- Ensure contractor_verifications table exists before adding trigger
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'contractor_verifications') THEN
    RAISE EXCEPTION 'Table contractor_verifications does not exist';
  END IF;
END $$;

CREATE TRIGGER audit_contractor_verifications
  AFTER INSERT OR UPDATE OR DELETE ON contractor_verifications
  FOR EACH ROW EXECUTE FUNCTION log_admin_action();
      TG_TABLE_NAME,
      COALESCE(NEW.id, OLD.id),
      CASE
        WHEN TG_OP = 'INSERT' THEN jsonb_build_object('new', to_jsonb(NEW))
        ELSE jsonb_build_object('old', to_jsonb(OLD))
      END
    );
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add audit triggers
CREATE TRIGGER audit_contractor_verifications
  AFTER INSERT OR UPDATE OR DELETE ON contractor_verifications
  FOR EACH ROW EXECUTE FUNCTION log_admin_action();

CREATE TRIGGER audit_warranty_claims
  AFTER INSERT OR UPDATE OR DELETE ON warranty_claims
  FOR EACH ROW EXECUTE FUNCTION log_admin_action();

-- Add RLS policies
CREATE POLICY "Only admins can view admin_users"
  ON admin_users
  FOR SELECT
  TO authenticated
  USING (is_admin(auth.uid()));

CREATE POLICY "Only super admins can manage admin_users"
  ON admin_users
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM admin_users
      WHERE user_id = auth.uid()
      AND role = 'super_admin'
      AND is_active = true
    )
  );

CREATE POLICY "Only admins can view audit logs"
  ON admin_audit_logs
  FOR SELECT
  TO authenticated
  USING (is_admin(auth.uid()));

-- Update existing policies for contractor verifications
DROP POLICY IF EXISTS "Contractors can view own verification" ON contractor_verifications;
CREATE POLICY "Access contractor verifications"
  ON contractor_verifications
  FOR ALL
  TO authenticated
  USING (
    contractor_id = auth.uid() OR
    is_admin(auth.uid())
  )
  WITH CHECK (
    contractor_id = auth.uid() OR
    is_admin(auth.uid())
  );

-- Update existing policies for warranty claims
DROP POLICY IF EXISTS "Users can view own warranty claims" ON warranty_claims;
CREATE POLICY "Access warranty claims"
  ON warranty_claims
  FOR ALL
  TO authenticated
  USING (
    client_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM service_packages sp
      JOIN bookings b ON b.service_package_id = sp.id
      WHERE b.id = warranty_claims.booking_id
      AND sp.contractor_id = auth.uid()
    ) OR
    is_admin(auth.uid())
  )
  WITH CHECK (
    client_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM service_packages sp
      JOIN bookings b ON b.service_package_id = sp.id
      WHERE b.id = warranty_claims.booking_id
      AND sp.contractor_id = auth.uid()
    ) OR
    is_admin(auth.uid())
  );